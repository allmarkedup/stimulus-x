{"mappings":"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","sources":["src/index.js","src/lifecycle.js","src/scheduler.js","src/controller.js","src/reactivity.js","src/mutation.js","src/options.js","src/utils.js","src/directives.js","src/modifiers.js","src/modifiers/downcase.js","src/modifiers/gt.js","src/modifiers/gte.js","src/modifiers/is.js","src/modifiers/is-not.js","src/modifiers/lt.js","src/modifiers/lte.js","src/modifiers/not.js","src/modifiers/strip.js","src/modifiers/upcase.js","src/directives/attr.js","src/attributes.js","src/classes.js","src/directives/text.js"],"sourcesContent":["import { init } from \"./lifecycle\";\nimport { modifier } from \"./modifiers\";\nimport { directive } from \"./directives\";\nimport { nextTick } from \"./scheduler\";\n\nimport \"./modifiers/downcase\";\nimport \"./modifiers/gt\";\nimport \"./modifiers/gte\";\nimport \"./modifiers/is\";\nimport \"./modifiers/is-not\";\nimport \"./modifiers/lt\";\nimport \"./modifiers/lte\";\nimport \"./modifiers/not\";\nimport \"./modifiers/strip\";\nimport \"./modifiers/upcase\";\n\nimport \"./directives/attr\";\nimport \"./directives/text\";\n\nconst StimulusX = {\n  init,\n  modifier,\n  directive,\n  nextTick,\n};\n\nexport default StimulusX;\n\nexport { nextTick };\n","import { nextTick } from \"./scheduler\";\nimport { createReactiveControllerClass } from \"./controller\";\nimport { walk } from \"./utils\";\nimport {\n  startObservingMutations,\n  onAttributesAdded,\n  onElAdded,\n  onElRemoved,\n  cleanupAttributes,\n  cleanupElement,\n  mutateDom,\n} from \"./mutation\";\nimport { deferHandlingDirectives, directives } from \"./directives\";\nimport { setOptions } from \"./options\";\n\nlet markerCount = 1;\nlet application = null;\n\nexport function init(app, opts = {}) {\n  const { optIn } = setOptions(opts);\n  application = app;\n\n  // Override controller registration to insert a reactive subclass instead of the original\n  application.register = function (identifier, ControllerClass) {\n    let controllerConstructor;\n    if (optIn === false || ControllerClass.reactive === true) {\n      controllerConstructor = createReactiveControllerClass(ControllerClass, application);\n    } else {\n      controllerConstructor = ControllerClass;\n    }\n\n    application.load({\n      identifier,\n      controllerConstructor,\n    });\n  };\n\n  // Handle re-initializing reactive effects after Turbo morphing\n  document.addEventListener(\"turbo:before-morph-element\", beforeMorphElementCallback);\n  document.addEventListener(\"turbo:morph-element\", morphElementCallback);\n\n  // start watching the dom for changes\n  startObservingMutations();\n\n  onElAdded((el) => {\n    // Controller root elements init their own tree when connected so we can skip them.\n    // if (el.hasAttribute(\"data-controller\")) return;\n    nextTick(() => initTree(el));\n  });\n\n  onElRemoved((el) => nextTick(() => destroyTree(el)));\n\n  onAttributesAdded((el, attrs) => {\n    handleValueAttributes(el, attrs);\n    directives(el, attrs).forEach((handle) => handle());\n  });\n}\n\nexport function initTree(el) {\n  deferHandlingDirectives(() => {\n    walk(el, (el) => {\n      if (el.__stimulusX_marker) return;\n\n      directives(el, el.attributes).forEach((handle) => handle());\n\n      el.__stimulusX_marker = markerCount++;\n    });\n  });\n}\n\nexport function destroyTree(root) {\n  walk(root, (el) => {\n    cleanupElement(el);\n    cleanupAttributes(el);\n    delete el.__stimulusX_directives;\n    delete el.__stimulusX_marker;\n  });\n}\n\nexport function beforeMorphElementCallback({ target, detail: { newElement } }) {\n  if (!newElement && target.__stimulusX_marker) {\n    return destroyTree(target);\n  }\n  delete target.__stimulusX_marker;\n}\n\nexport function morphElementCallback({ target, detail: { newElement } }) {\n  if (newElement) initTree(target);\n}\n\n// Changes to controller value attributes in the DOM do not call\n// any properties on the controller so changes are not detected.\n// To fix this any value attribute changes are registered by calling\n// the value setter on the proxy with the current value - the value is\n// unchanged but calling the getter triggers any related effects.\nfunction handleValueAttributes(el, attrs) {\n  if (!el.hasAttribute(\"data-controller\")) return;\n\n  const controllerNames = el\n    .getAttribute(\"data-controller\")\n    .trim()\n    .split(\" \")\n    .filter((e) => e);\n\n  const valueAttributeMatcher = new RegExp(\n    `^data-(${controllerNames.join(\"|\")})-([a-zA-Z0-9\\-_]+)-value$`\n  );\n\n  for (let i = 0; i < attrs.length; i++) {\n    const attr = attrs[i];\n    const matches = attr.name.match(valueAttributeMatcher);\n    if (matches && matches.length) {\n      const identifier = matches[1];\n      const valueName = matches[2];\n      const controller = application.getControllerForElementAndIdentifier(el, identifier);\n\n      mutateDom(() => {\n        controller[`${valueName}Value`] = controller[`${valueName}Value`];\n      });\n    }\n  }\n}\n\nexport { application };\n","let flushPending = false;\nlet flushing = false;\nlet queue = [];\nlet lastFlushedIndex = -1;\nlet tickStack = [];\nlet isHolding = false;\n\nexport function scheduler(callback) {\n  queueJob(callback);\n}\n\nexport function queueJob(job) {\n  if (!queue.includes(job)) queue.push(job);\n\n  queueFlush();\n}\n\nexport function dequeueJob(job) {\n  let index = queue.indexOf(job);\n\n  if (index !== -1 && index > lastFlushedIndex) queue.splice(index, 1);\n}\n\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n\n    queueMicrotask(flushJobs);\n  }\n}\n\nexport function flushJobs() {\n  flushPending = false;\n  flushing = true;\n\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n    lastFlushedIndex = i;\n  }\n\n  queue.length = 0;\n  lastFlushedIndex = -1;\n\n  flushing = false;\n}\n\nexport function nextTick(callback = () => {}) {\n  queueMicrotask(() => {\n    isHolding ||\n      setTimeout(() => {\n        releaseNextTicks();\n      });\n  });\n\n  return new Promise((res) => {\n    tickStack.push(() => {\n      callback();\n      res();\n    });\n  });\n}\n\nexport function releaseNextTicks() {\n  isHolding = false;\n\n  while (tickStack.length) tickStack.shift()();\n}\n\nexport function holdNextTicks() {\n  isHolding = true;\n}\n","import { getProperty } from \"dot-prop\";\nimport { application } from \"./lifecycle\";\nimport { reactive, shallowReactive, watch } from \"./reactivity\";\nimport { mutateDom } from \"./mutation\";\nimport { nextTick } from \"./scheduler\";\nimport { initTree } from \"./lifecycle\";\nimport { getOption } from \"./options\";\n\nexport function createReactiveControllerClass(ControllerClass) {\n  return class extends ControllerClass {\n    constructor(context) {\n      super(context);\n\n      // Override the attribute setter so that our mutation observer doesn't pick up on changes\n      // that are also already being handled directly by Stimulus.\n      const setData = this.data.set;\n      this.data.set = (key, value) => {\n        mutateDom(() => setData.call(this.data, key, value));\n      };\n\n      // Create a reactive controller object\n      const trackDeep = getOption(\"trackDeep\") || this.constructor.reactive === \"deep\";\n      const reactiveSelf = trackDeep ? reactive(this) : shallowReactive(this);\n\n      // Initialize watched property callbacks\n      const watchedProps = this.constructor.watch || [];\n      watchedProps.forEach((prop) => watchControllerProperty(reactiveSelf, prop));\n\n      // Return the reactive controller instance\n      return reactiveSelf;\n    }\n\n    connect() {\n      // Initialize the DOM tree and run directives when connected\n      super.connect();\n      nextTick(() => initTree(this.element));\n    }\n  };\n}\n\nexport function getClosestController(el, identifier) {\n  const controllerElement = el.closest(`[data-controller~=\"${identifier}\"]`);\n  if (controllerElement) {\n    return application.getControllerForElementAndIdentifier(controllerElement, identifier);\n  }\n}\n\nexport function evaluateControllerProperty(controller, property) {\n  let value = getProperty(controller, property);\n  if (typeof value === \"function\") {\n    value = value.apply(controller);\n  }\n  return value;\n}\n\nexport function watchControllerProperty(controller, propertyRef) {\n  const getter = () => evaluateControllerProperty(controller, propertyRef);\n  const cleanup = watch(getter, (value, oldValue) => {\n    callCallbacks(controller, propertyRef, value, oldValue, false);\n  });\n\n  // Run once on creation\n  callCallbacks(controller, propertyRef, getter(), undefined, true);\n\n  const rootElement = controller.element;\n  if (!rootElement.__stimulusX_cleanups) rootElement.__stimulusX_cleanups = [];\n  rootElement.__stimulusX_cleanups.push(cleanup);\n}\n\nfunction callCallbacks(controller, propertyRef, value, oldValue, initial) {\n  // Generic callback, called when _any_ watched property changes\n  if (typeof controller.watchedPropertyChanged === \"function\") {\n    controller.watchedPropertyChanged(propertyRef, value, oldValue, { initial });\n  }\n\n  // Property-specific change callback\n  const propertyWatcherCallback =\n    controller[`${getCamelizedPropertyRef(propertyRef)}PropertyChanged`];\n  if (typeof propertyWatcherCallback === \"function\") {\n    propertyWatcherCallback.call(controller, value, oldValue, { initial });\n  }\n}\n\nfunction getCamelizedPropertyRef(propertyRef) {\n  return camelCase(propertyRef.replace(\".\", \" \"));\n}\n\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\n","import {\n  effect as vueEffect,\n  stop as release,\n  reactive as vueReactive,\n  shallowReactive as vueShallowReactive,\n  isReactive as vueIsReactive,\n} from \"@vue/reactivity/dist/reactivity.esm-browser.prod.js\";\nimport { scheduler } from \"./scheduler\";\n\nconst isReactive = vueIsReactive;\nconst reactive = vueReactive;\nconst shallowReactive = vueShallowReactive;\n\nconst effect = (callback) =>\n  vueEffect(callback, {\n    scheduler: scheduler((task) => task),\n  });\n\nexport function elementBoundEffect(el) {\n  let cleanup = () => {};\n\n  let wrappedEffect = (callback) => {\n    let effectReference = effect(callback);\n\n    if (!el.__stimulusX_effects) {\n      el.__stimulusX_effects = new Set();\n    }\n\n    el.__stimulusX_effects.add(effectReference);\n\n    cleanup = () => {\n      if (effectReference === undefined) return;\n\n      el.__stimulusX_effects.delete(effectReference);\n\n      release(effectReference);\n    };\n\n    return effectReference;\n  };\n\n  return [\n    wrappedEffect,\n    () => {\n      cleanup();\n    },\n  ];\n}\n\nexport function watch(getter, callback) {\n  let firstTime = true;\n  let oldValue;\n\n  let effectReference = effect(() => {\n    let value = getter();\n\n    // JSON.stringify touches every single property at any level enabling deep watching\n    JSON.stringify(value);\n\n    if (!firstTime) {\n      // We have to queue this watcher as a microtask so that\n      // the watcher doesn't pick up its own dependencies.\n      queueMicrotask(() => {\n        callback(value, oldValue);\n\n        oldValue = value;\n      });\n    } else {\n      oldValue = value;\n    }\n\n    firstTime = false;\n  });\n\n  return () => release(effectReference);\n}\n\nexport { effect, release, reactive, shallowReactive, isReactive };\n","import { dequeueJob } from \"./scheduler\";\nlet onAttributeAddeds = [];\nlet onElRemoveds = [];\nlet onElAddeds = [];\nlet onValueAttributeChangeds = [];\nlet currentlyObserving = false;\nlet isCollecting = false;\nlet deferredMutations = [];\nlet observer = new MutationObserver(onMutate);\n\nexport function onElAdded(callback) {\n  onElAddeds.push(callback);\n}\n\nexport function onElRemoved(el, callback) {\n  if (typeof callback === \"function\") {\n    if (!el.__stimulusX_cleanups) el.__stimulusX_cleanups = [];\n    el.__stimulusX_cleanups.push(callback);\n  } else {\n    callback = el;\n    onElRemoveds.push(callback);\n  }\n}\n\nexport function onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\n\nexport function onAttributeRemoved(el, name, callback) {\n  if (!el.__stimulusX_attributeCleanups) el.__stimulusX_attributeCleanups = {};\n  if (!el.__stimulusX_attributeCleanups[name]) el.__stimulusX_attributeCleanups[name] = [];\n\n  el.__stimulusX_attributeCleanups[name].push(callback);\n}\n\nexport function onValueAttributeChanged(callback) {\n  onValueAttributeChangeds.push(callback);\n}\n\nexport function cleanupAttributes(el, names) {\n  if (!el.__stimulusX_attributeCleanups) return;\n\n  Object.entries(el.__stimulusX_attributeCleanups).forEach(([name, value]) => {\n    if (names === undefined || names.includes(name)) {\n      value.forEach((i) => i());\n\n      delete el.__stimulusX_attributeCleanups[name];\n    }\n  });\n}\n\nexport function cleanupElement(el) {\n  el.__stimulusX_cleanups?.forEach(dequeueJob);\n\n  while (el.__stimulusX_cleanups?.length) el.__stimulusX_cleanups.pop()();\n}\n\nexport function startObservingMutations() {\n  observer.observe(document, {\n    subtree: true,\n    childList: true,\n    attributes: true,\n    attributeOldValue: true,\n  });\n\n  currentlyObserving = true;\n}\n\nexport function stopObservingMutations() {\n  flushObserver();\n\n  observer.disconnect();\n\n  currentlyObserving = false;\n}\n\nlet queuedMutations = [];\n\nexport function flushObserver() {\n  let records = observer.takeRecords();\n\n  queuedMutations.push(() => records.length > 0 && onMutate(records));\n\n  let queueLengthWhenTriggered = queuedMutations.length;\n\n  queueMicrotask(() => {\n    // If these two lengths match, then we KNOW that this is the LAST\n    // flush in the current event loop. This way, we can process\n    // all mutations in one batch at the end of everything...\n    if (queuedMutations.length === queueLengthWhenTriggered) {\n      // Now Alpine can process all the mutations...\n      while (queuedMutations.length > 0) queuedMutations.shift()();\n    }\n  });\n}\n\nexport function mutateDom(callback) {\n  if (!currentlyObserving) return callback();\n\n  stopObservingMutations();\n\n  let result = callback();\n\n  startObservingMutations();\n\n  return result;\n}\n\nexport function deferMutations() {\n  isCollecting = true;\n}\n\nexport function flushAndStopDeferringMutations() {\n  isCollecting = false;\n\n  onMutate(deferredMutations);\n\n  deferredMutations = [];\n}\n\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n\n    return;\n  }\n\n  let addedNodes = [];\n  let removedNodes = new Set();\n  let addedAttributes = new Map();\n  let removedAttributes = new Map();\n\n  for (let i = 0; i < mutations.length; i++) {\n    if (mutations[i].target.__stimulusX_ignoreMutationObserver) continue;\n\n    if (mutations[i].type === \"childList\") {\n      mutations[i].removedNodes.forEach((node) => {\n        if (node.nodeType !== 1) return;\n\n        // No need to process removed nodes that haven't been initialized by Alpine...\n        if (!node.__stimulusX_marker) return;\n\n        removedNodes.add(node);\n      });\n\n      mutations[i].addedNodes.forEach((node) => {\n        if (node.nodeType !== 1) return;\n\n        // If the node is a removal as well, that means it's a \"move\" operation and we'll leave it alone...\n        if (removedNodes.has(node)) {\n          removedNodes.delete(node);\n\n          return;\n        }\n\n        // If the node has already been initialized, we'll leave it alone...\n        if (node.__stimulusX_marker) return;\n\n        addedNodes.push(node);\n      });\n    }\n\n    if (mutations[i].type === \"attributes\") {\n      let el = mutations[i].target;\n      let name = mutations[i].attributeName;\n      let oldValue = mutations[i].oldValue;\n\n      let add = () => {\n        if (!addedAttributes.has(el)) addedAttributes.set(el, []);\n\n        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });\n      };\n\n      let remove = () => {\n        if (!removedAttributes.has(el)) removedAttributes.set(el, []);\n\n        removedAttributes.get(el).push(name);\n      };\n\n      // let valueAttributeChanged = () => {\n\n      // };\n\n      // New attribute.\n      if (el.hasAttribute(name) && oldValue === null) {\n        add();\n        // Changed attribute.\n      } else if (el.hasAttribute(name)) {\n        remove();\n        add();\n        // Removed attribute.\n      } else {\n        remove();\n      }\n    }\n  }\n\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach((i) => i(el, attrs));\n  });\n\n  // There are two special scenarios we need to account for when using the mutation\n  // observer to init and destroy elements. First, when a node is \"moved\" on the page,\n  // it's registered as both an \"add\" and a \"remove\", so we want to skip those.\n  // (This is handled above by the .__stimulusX_marker conditionals...)\n  // Second, when a node is \"wrapped\", it gets registered as a \"removal\" and the wrapper\n  // as an \"addition\". We don't want to remove, then re-initialize the node, so we look\n  // and see if it's inside any added nodes (wrappers) and skip it.\n  // (This is handled below by the .contains conditional...)\n\n  for (let node of removedNodes) {\n    if (addedNodes.some((i) => i.contains(node))) continue;\n\n    onElRemoveds.forEach((i) => i(node));\n  }\n\n  for (let node of addedNodes) {\n    if (!node.isConnected) continue;\n\n    onElAddeds.forEach((i) => i(node));\n  }\n\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n}\n","const defaultOptions = {\n  optIn: false,\n  attributePrefix: \"data-bind-\",\n  shorthandAttributePrefix: \"sx-\",\n  compileDirectives: true,\n  trackDeep: false,\n};\n\nlet options = defaultOptions;\n\nexport function getOption(key) {\n  return options[key];\n}\n\nexport function getOptions() {\n  return options;\n}\n\nexport function setOptions(opts) {\n  options = Object.assign({}, defaultOptions, opts);\n  return options;\n}\n","export function camelCase(subject) {\n  return subject\n    .replace(/:/g, \"_\")\n    .split(\"_\")\n    .map((word, index) => (index === 0 ? word : word[0].toUpperCase() + word.slice(1)))\n    .join(\"\");\n}\n\nexport function walk(el, callback) {\n  let skip = false;\n  callback(el, () => (skip = true));\n  if (skip) return;\n\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n\nexport function isEqual(x, y) {\n  const ok = Object.keys,\n    tx = typeof x,\n    ty = typeof y;\n  return x && y && tx === \"object\" && tx === ty\n    ? ok(x).length === ok(y).length && ok(x).every((key) => isEqual(x[key], y[key]))\n    : x === y;\n}\n","import { onAttributeRemoved } from \"./mutation\";\nimport { elementBoundEffect, isReactive } from \"./reactivity\";\nimport { applyModifiers, parseModifier } from \"./modifiers\";\nimport { getClosestController, evaluateControllerProperty } from \"./controller\";\nimport { getOption } from \"./options\";\n\nlet directiveHandlers = {};\nlet isDeferringHandlers = false;\nlet directiveHandlerStacks = new Map();\nlet currentHandlerStackKey = Symbol();\n\nexport function directive(name, callback) {\n  directiveHandlers[name] = callback;\n}\n\nexport function directiveExists(name) {\n  return Object.keys(directiveHandlers).includes(name);\n}\n\nexport function directives(el, attributes) {\n  let directives = [];\n\n  if (el.__stimulusX_directives) {\n    directives = el.__stimulusX_directives;\n  } else {\n    directives = Array.from(attributes).filter(isDirectiveAttribute).map(toParsedDirectives);\n    if (getOption(\"compileDirectives\") === true) el.__stimulusX_directives = directives;\n  }\n\n  return directives\n    .flat()\n    .filter((d) => d)\n    .map((directive) => getDirectiveHandler(el, directive));\n}\n\nexport function deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n\n  let key = Symbol();\n\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n\n  let flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length) directiveHandlerStacks.get(key).shift()();\n    directiveHandlerStacks.delete(key);\n  };\n\n  let stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n\n  callback(flushHandlers);\n  stopDeferring();\n}\n\nexport function getElementBoundUtilities(el) {\n  let cleanups = [];\n  let cleanup = (callback) => cleanups.push(callback);\n  let [effect, cleanupEffect] = elementBoundEffect(el);\n\n  cleanups.push(cleanupEffect);\n\n  let utilities = {\n    effect,\n    cleanup,\n  };\n\n  let doCleanup = () => {\n    cleanups.forEach((i) => i());\n  };\n\n  return [utilities, doCleanup];\n}\n\nexport function getDirectiveHandler(el, directive) {\n  let handler = directiveHandlers[directive.type] || (() => {});\n  let [utilities, cleanup] = getElementBoundUtilities(el);\n\n  onAttributeRemoved(el, directive.originalAttribute.name, cleanup);\n\n  let wrapperHandler = () => {\n    let controller = getClosestController(el, directive.identifier);\n    if (controller) {\n      if (!isReactive(controller)) {\n        console.warn(\n          `StimulusX: Directive attached to non-reactive controller '${directive.identifier}'`,\n          el\n        );\n        return;\n      }\n      handler = handler.bind(handler, el, directive, {\n        ...utilities,\n        evaluate: evaluator(controller),\n        modify: applyModifiers,\n      });\n      isDeferringHandlers\n        ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler)\n        : handler();\n    } else {\n      console.error(`Controller '${directive.identifier}' not found`);\n    }\n  };\n\n  return wrapperHandler;\n}\n\nfunction evaluator(controller) {\n  return (property) => evaluateControllerProperty(controller, property);\n}\n\nfunction matchedAttributeRegex() {\n  const prefix = getOption(\"attributePrefix\");\n  return new RegExp(`${prefix}(${directiveNames().join(\"|\")})$`);\n}\n\nfunction isDirectiveAttribute({ name }) {\n  const prefix = getOption(\"shorthandAttributePrefix\");\n  return name.startsWith(prefix) || matchedAttributeRegex().test(name);\n}\n\nfunction directiveNames() {\n  return Object.keys(directiveHandlers);\n}\n\nfunction toParsedDirectives(attr) {\n  if (attr.name.startsWith(getOption(\"shorthandAttributePrefix\"))) {\n    return parseShorthandSyntaxAttributeDirectives(attr);\n  } else {\n    return parseStandardSyntaxAttributeDirectives(attr);\n  }\n}\n\nfunction parseStandardSyntaxAttributeDirectives(originalAttribute) {\n  const { name, value } = originalAttribute;\n  const type = name.match(matchedAttributeRegex())[1];\n  const expressions = value\n    .trim()\n    .split(/\\s+(?![^\\(]*\\))/) // split string on all spaces not contained in parentheses\n    .filter((e) => e);\n\n  return expressions.map((expression) => {\n    const attrMatch = expression.match(/^([a-zA-Z0-9\\-_]+)~/);\n    const attributeName = attrMatch ? attrMatch[1] : null;\n    const bindingExpression = attributeName\n      ? expression.replace(`${attributeName}~`, \"\")\n      : expression;\n\n    return {\n      originalAttribute,\n      attributeName,\n      type,\n      ...parseBindingValueExpression(bindingExpression),\n    };\n  });\n}\n\nfunction parseShorthandSyntaxAttributeDirectives(originalAttribute) {\n  const { name, value } = originalAttribute;\n  const prefix = getOption(\"shorthandAttributePrefix\");\n  const attributeName = name.replace(prefix, \"\");\n  const type = directiveNames().includes(attributeName) ? attributeName : \"attr\";\n\n  return [\n    {\n      originalAttribute,\n      attributeName,\n      type,\n      ...parseBindingValueExpression(value),\n    },\n  ];\n}\n\nfunction parseBindingValueExpression(bindingExpression) {\n  let [valueExpression, modifiersExpression = \"\"] = bindingExpression.trim().split(/\\:(.*)/);\n  const modifiers = modifiersExpression.match(/[^:\\]]+(?=[^\\]]*$)/g) || [];\n\n  if (valueExpression[0] === \"!\") {\n    // Shorthand `:not` modifier syntax\n    valueExpression = valueExpression.slice(1);\n    modifiers.push(\"not\");\n  }\n\n  const identifierMatch = valueExpression.match(/^([a-zA-Z0-9\\-_]+)#/);\n  if (!identifierMatch) {\n    console.warn(`Invalid binding descriptor ${bindingExpression}`);\n    return null;\n  }\n\n  const identifier = identifierMatch[1];\n  const property = identifier ? valueExpression.replace(`${identifier}#`, \"\") : valueExpression;\n\n  return {\n    identifier,\n    property,\n    modifiers: modifiers.map((m) => parseModifier(m)),\n  };\n}\n","const modifierHandlers = [];\n\nexport function modifier(name, handler) {\n  modifierHandlers.push({\n    name,\n    handler,\n  });\n}\n\nexport function applyModifiers(value, modifiers = []) {\n  return modifiers.reduce((value, modifier) => {\n    const { name, args } = modifier;\n    if (modifierExists(name)) {\n      return applyModifier(value, name, args);\n    } else {\n      console.error(`Unknown modifier '${modifier}'`);\n      return value;\n    }\n  }, value);\n}\n\nfunction applyModifier(value, name, args = []) {\n  return getModifier(name).handler(value, args);\n}\n\nfunction modifierExists(name) {\n  return !!getModifier(name);\n}\n\nfunction getModifier(name) {\n  return modifierHandlers.find((modifier) => modifier.name === name);\n}\n\nexport function parseModifier(modifier) {\n  const matches = modifier.match(/^([^\\(]+)(?=\\((?=(.*)\\)$)|$)/);\n\n  if (matches && typeof matches[2] !== \"undefined\") {\n    const argStr = matches[2].trim();\n    const firstChar = argStr[0];\n    const lastChar = argStr[argStr.length - 1];\n    let argValue = null;\n\n    if (\n      (firstChar === \"'\" && lastChar === \"'\") ||\n      (firstChar === \"`\" && lastChar === \"`\") ||\n      (firstChar === `\"` && lastChar === `\"`)\n    ) {\n      argValue = argStr.slice(1, argStr.length - 1);\n    } else {\n      argValue = JSON.parse(argStr);\n    }\n\n    return { name: matches[1], args: [argValue] };\n  } else {\n    return { name: modifier, args: [] };\n  }\n}\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"downcase\", (value) => value.toString().toLowerCase());\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"gt\", (value, args = []) => {\n  if (args.length === 0) {\n    console.warn(\"Missing argument for `:gt` modifier\");\n    return false;\n  }\n\n  return value > args[0];\n});\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"gte\", (value, args = []) => {\n  if (args.length === 0) {\n    console.warn(\"Missing argument for `:gte` modifier\");\n    return false;\n  }\n\n  return value >= args[0];\n});\n","import { modifier } from \"../modifiers\";\nimport { isEqual } from \"../utils\";\n\nmodifier(\"is\", (value, args = []) => {\n  if (args.length === 0) {\n    console.warn(\"Missing argument for `:is` modifier\");\n    return false;\n  } else {\n    return isEqual(value, args[0]);\n  }\n});\n","import { modifier } from \"../modifiers\";\nimport { isEqual } from \"../utils\";\n\nmodifier(\"isNot\", (value, args = []) => {\n  if (args.length === 0) {\n    console.warn(\"Missing argument for `:isNot` modifier\");\n    return false;\n  } else {\n    return !isEqual(value, args[0]);\n  }\n});\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"lt\", (value, args = []) => {\n  if (args.length === 0) {\n    console.warn(\"Missing argument for `:lt` modifier\");\n    return false;\n  }\n\n  return value < args[0];\n});\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"lte\", (value, args = []) => {\n  if (args.length === 0) {\n    console.warn(\"Missing argument for `:lte` modifier\");\n    return false;\n  }\n\n  return value <= args[0];\n});\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"not\", (value) => !value);\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"strip\", (value) => value.toString().trim());\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"upcase\", (value) => value.toString().toUpperCase());\n","import { directive } from \"../directives\";\nimport { mutateDom } from \"../mutation\";\nimport { bind } from \"../attributes\";\n\ndirective(\"attr\", (el, { property, attributeName, modifiers }, { effect, evaluate, modify }) => {\n  effect(() => {\n    mutateDom(() => {\n      const value = modify(evaluate(property), modifiers);\n      bind(el, attributeName, value);\n    });\n  });\n});\n","import { setClasses } from \"./classes\";\n\n// As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\nconst booleanAttributes = new Set([\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"inert\",\n  \"ismap\",\n  \"itemscope\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\",\n]);\n\nconst preserveIfFalsey = [\"aria-pressed\", \"aria-checked\", \"aria-expanded\", \"aria-selected\"];\n\nexport function bind(element, name, value) {\n  switch (name) {\n    case \"class\":\n      bindClasses(element, value);\n      break;\n\n    case \"checked\":\n    case \"selected\":\n      bindAttributeAndProperty(element, name, value);\n      break;\n\n    default:\n      bindAttribute(element, name, value);\n      break;\n  }\n}\n\nfunction bindClasses(element, value) {\n  if (element.__stimulusX_undoClasses) element.__stimulusX_undoClasses();\n  element.__stimulusX_undoClasses = setClasses(element, value);\n}\n\nfunction bindAttribute(el, name, value) {\n  if ([null, undefined, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name)) value = name;\n    setIfChanged(el, name, value);\n  }\n}\n\nfunction bindAttributeAndProperty(el, name, value) {\n  bindAttribute(el, name, value);\n  setPropertyIfChanged(el, name, value);\n}\n\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\n\nfunction setPropertyIfChanged(el, propName, value) {\n  if (el[propName] !== value) {\n    el[propName] = value;\n  }\n}\n\nfunction isBooleanAttr(attrName) {\n  return booleanAttributes.has(attrName);\n}\n\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return !preserveIfFalsey.includes(name);\n}\n","export function setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  }\n  return setClassesFromString(el, value);\n}\n\nfunction setClassesFromString(el, classString) {\n  classString = classString || \"\";\n  let missingClasses = (classString) =>\n    classString\n      .split(\" \")\n      .filter((i) => !el.classList.contains(i))\n      .filter(Boolean);\n\n  let classes = missingClasses(classString);\n  el.classList.add(...classes);\n\n  return () => el.classList.remove(...classes);\n}\n\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n\n  let forAdd = Object.entries(classObject)\n    .flatMap(([classString, bool]) => (bool ? split(classString) : false))\n    .filter(Boolean);\n  let forRemove = Object.entries(classObject)\n    .flatMap(([classString, bool]) => (!bool ? split(classString) : false))\n    .filter(Boolean);\n\n  let added = [];\n  let removed = [];\n\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n","import { directive } from \"../directives\";\nimport { mutateDom } from \"../mutation\";\n\ndirective(\"text\", (el, { property, modifiers }, { effect, evaluate, modify }) => {\n  effect(() =>\n    mutateDom(() => {\n      const value = modify(evaluate(property), modifiers);\n      el.textContent = value?.toString();\n    })\n  );\n});\n"],"names":[],"version":3,"file":"stimulus-x.js.map"}