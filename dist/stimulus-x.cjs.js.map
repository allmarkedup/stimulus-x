{"mappings":"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","sources":["src/index.js","src/stimulus-x.js","src/modifiers.js","src/directives.js","src/mutation.js","src/scheduler.js","src/reactivity.js","src/controller.js","src/utils.js","src/modifiers/downcase.js","src/modifiers/not.js","src/modifiers/upcase.js","src/directives/attr.js","src/attributes.js","src/classes.js","src/directives/text.js"],"sourcesContent":["import StimulusX from \"./stimulus-x.js\";\n\nimport \"./modifiers/downcase.js\";\nimport \"./modifiers/not.js\";\nimport \"./modifiers/upcase.js\";\n\nimport \"./directives/attr.js\";\nimport \"./directives/text.js\";\n\nexport default StimulusX;\n","import { modifier } from \"./modifiers\";\nimport { directive } from \"./directives\";\nimport { nextTick } from \"./scheduler\";\nimport { createReactiveControllerClass } from \"./controller\";\nimport { walk } from \"./utils\";\nimport {\n  startObservingMutations,\n  onAttributesAdded,\n  onElAdded,\n  onElRemoved,\n  cleanupAttributes,\n  cleanupElement,\n  mutateDom,\n} from \"./mutation\";\nimport { deferHandlingDirectives, directives } from \"./directives\";\n\nconst StimulusX = {};\nlet markerCount = 1;\n\nStimulusX.extend = function (application) {\n  this.application = application;\n\n  // Override controller registration to insert a reactive subclass instead of the original\n  application.register = function (identifier, ControllerClass) {\n    const controllerConstructor = createReactiveControllerClass(ControllerClass, application);\n    application.load({\n      identifier,\n      controllerConstructor,\n    });\n  };\n\n  startObservingMutations();\n\n  onElAdded((el) => initTree(el));\n  onElRemoved((el) => destroyTree(el));\n\n  onAttributesAdded((el, attrs) => {\n    handleValueAttributes(el, attrs);\n    directives(el, attrs).forEach((handle) => handle(StimulusX.application));\n  });\n\n  nextTick(() => {\n    rootElements().forEach((el) => initTree(el));\n  });\n};\n\nStimulusX.modifier = modifier;\nStimulusX.directive = directive;\n\nfunction rootElements() {\n  return Array.from(\n    document.querySelectorAll(\"[data-controller]:not([data-controller] [data-controller])\")\n  );\n}\n\nfunction initTree(el) {\n  deferHandlingDirectives(() => {\n    walk(el, (el) => {\n      if (el.__stimulusX_marker) return;\n\n      directives(el, el.attributes).forEach((handle) => handle(StimulusX.application));\n\n      el.__stimulusX_marker = markerCount++;\n    });\n  });\n}\n\nfunction destroyTree(root) {\n  walk(root, (el) => {\n    cleanupElement(el);\n    cleanupAttributes(el);\n    delete el.__stimulusX_marker;\n  });\n}\n\n// Changes to controller value attributes in the DOM do not call\n// any properties on the controller so changes are not detected.\n// To fix this any value attribute changes are registered by calling\n// the value setter on the proxy with the current value - the value is\n// unchanged but calling the getter triggers any related effects.\nfunction handleValueAttributes(el, attrs) {\n  if (!el.hasAttribute(\"data-controller\")) return;\n\n  const controllerNames = el\n    .getAttribute(\"data-controller\")\n    .trim()\n    .split(\" \")\n    .filter((e) => e);\n\n  const valueAttributeMatcher = new RegExp(\n    `^data-(${controllerNames.join(\"|\")})-([a-zA-Z0-9\\-_]+)-value$`\n  );\n\n  for (let i = 0; i < attrs.length; i++) {\n    const attr = attrs[i];\n    const matches = attr.name.match(valueAttributeMatcher);\n    if (matches && matches.length) {\n      const identifier = matches[1];\n      const valueName = matches[2];\n      const controller = StimulusX.application.getControllerForElementAndIdentifier(el, identifier);\n\n      mutateDom(() => {\n        controller[`${valueName}Value`] = controller[`${valueName}Value`];\n      });\n    }\n  }\n}\n\nexport default StimulusX;\n","const modifierHandlers = [];\n\nexport function modifier(name, handler) {\n  modifierHandlers.push({\n    name,\n    handler,\n  });\n}\n\nexport function applyModifiers(value, modifiers = []) {\n  return modifiers.reduce((value, modifier) => {\n    if (modifierExists(modifier)) {\n      return applyModifier(modifier, value);\n    } else {\n      console.error(`Unknown modifier '${modifier}'`);\n      return value;\n    }\n  }, value);\n}\n\nfunction applyModifier(name, value) {\n  return getModifier(name).handler(value);\n}\n\nfunction modifierExists(name) {\n  return !!getModifier(name);\n}\n\nfunction getModifier(name) {\n  return modifierHandlers.find((modifier) => modifier.name === name);\n}\n","import { onAttributeRemoved } from \"./mutation\";\nimport { elementBoundEffect } from \"./reactivity\";\nimport { applyModifiers } from \"./modifiers\";\nimport { getClosestController, evaluateControllerProperty } from \"./controller\";\n\nlet directiveHandlers = {};\nlet isDeferringHandlers = false;\nlet directiveHandlerStacks = new Map();\nlet currentHandlerStackKey = Symbol();\n\nlet attributePrefix = \"data-bind-\";\n\nexport function directive(name, callback) {\n  directiveHandlers[name] = callback;\n}\n\nexport function directiveExists(name) {\n  return Object.keys(directiveHandlers).includes(name);\n}\n\nexport function directives(el, attributes) {\n  const directives = Array.from(attributes).filter(isDirectiveAttribute).map(toParsedDirectives);\n\n  return directives.flat().map((directive) => getDirectiveHandler(el, directive));\n}\n\nexport function deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n\n  let key = Symbol();\n\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n\n  let flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length) directiveHandlerStacks.get(key).shift()();\n    directiveHandlerStacks.delete(key);\n  };\n\n  let stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n\n  callback(flushHandlers);\n  stopDeferring();\n}\n\nexport function getElementBoundUtilities(el) {\n  let cleanups = [];\n  let cleanup = (callback) => cleanups.push(callback);\n  let [effect, cleanupEffect] = elementBoundEffect(el);\n\n  cleanups.push(cleanupEffect);\n\n  let utilities = {\n    effect,\n    cleanup,\n  };\n\n  let doCleanup = () => {\n    cleanups.forEach((i) => i());\n  };\n\n  return [utilities, doCleanup];\n}\n\nexport function getDirectiveHandler(el, directive) {\n  let handler = directiveHandlers[directive.type] || (() => {});\n  let [utilities, cleanup] = getElementBoundUtilities(el);\n\n  onAttributeRemoved(el, directive.attr, cleanup);\n\n  let wrapperHandler = (application) => {\n    let controller = getClosestController(el, directive.identifier, application);\n    if (controller) {\n      handler = handler.bind(handler, el, directive, {\n        ...utilities,\n        evaluate: evaluator(controller),\n        modify: applyModifiers,\n      });\n      isDeferringHandlers\n        ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler)\n        : handler();\n    } else {\n      console.error(`Controller '${directive.indentifier}' not found`);\n    }\n  };\n\n  return wrapperHandler;\n}\n\nfunction evaluator(controller) {\n  return (property) => evaluateControllerProperty(controller, property);\n}\n\nfunction matchedAttributeRegex() {\n  return new RegExp(`${attributePrefix}(${Object.keys(directiveHandlers).join(\"|\")})$`);\n}\n\nfunction isDirectiveAttribute({ name }) {\n  return matchedAttributeRegex().test(name);\n}\n\nfunction toParsedDirectives({ name, value }) {\n  const type = name.match(matchedAttributeRegex())[1];\n  const bindingExpressions = value\n    .trim()\n    .split(/\\s+/)\n    .filter((e) => e);\n\n  return bindingExpressions.map((bindingExpression) => {\n    const subjectMatch = bindingExpression.match(/^([a-zA-Z0-9\\-_]+)~/);\n    const subject = subjectMatch ? subjectMatch[1] : null;\n    let valueExpression = subject\n      ? bindingExpression.replace(`${subject}~`, \"\")\n      : bindingExpression;\n\n    let modifiers = valueExpression.match(/\\:[^:\\]]+(?=[^\\]]*$)/g) || [];\n    modifiers = modifiers.map((i) => i.replace(\":\", \"\"));\n\n    if (valueExpression[0] === \"!\") {\n      valueExpression = valueExpression.slice(1);\n      modifiers.push(\"not\");\n    }\n\n    valueExpression = valueExpression.split(\":\")[0];\n\n    const identifierMatch = valueExpression.match(/^([a-zA-Z0-9\\-_]+)#/);\n    const identifier = identifierMatch ? identifierMatch[1] : null;\n    const property = identifier ? valueExpression.replace(`${identifier}#`, \"\") : valueExpression;\n\n    return {\n      type,\n      subject,\n      modifiers,\n      identifier,\n      property,\n      attr: name,\n    };\n  });\n}\n","import { dequeueJob } from \"./scheduler\";\nlet onAttributeAddeds = [];\nlet onElRemoveds = [];\nlet onElAddeds = [];\nlet onValueAttributeChangeds = [];\nlet currentlyObserving = false;\nlet isCollecting = false;\nlet deferredMutations = [];\nlet observer = new MutationObserver(onMutate);\n\nexport function onElAdded(callback) {\n  onElAddeds.push(callback);\n}\n\nexport function onElRemoved(el, callback) {\n  if (typeof callback === \"function\") {\n    if (!el.__stimulusX_cleanups) el.__stimulusX_cleanups = [];\n    el.__stimulusX_cleanups.push(callback);\n  } else {\n    callback = el;\n    onElRemoveds.push(callback);\n  }\n}\n\nexport function onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\n\nexport function onAttributeRemoved(el, name, callback) {\n  if (!el.__stimulusX_attributeCleanups) el.__stimulusX_attributeCleanups = {};\n  if (!el.__stimulusX_attributeCleanups[name]) el.__stimulusX_attributeCleanups[name] = [];\n\n  el.__stimulusX_attributeCleanups[name].push(callback);\n}\n\nexport function onValueAttributeChanged(callback) {\n  onValueAttributeChangeds.push(callback);\n}\n\nexport function cleanupAttributes(el, names) {\n  if (!el.__stimulusX_attributeCleanups) return;\n\n  Object.entries(el.__stimulusX_attributeCleanups).forEach(([name, value]) => {\n    if (names === undefined || names.includes(name)) {\n      value.forEach((i) => i());\n\n      delete el.__stimulusX_attributeCleanups[name];\n    }\n  });\n}\n\nexport function cleanupElement(el) {\n  el.__stimulusX_cleanups?.forEach(dequeueJob);\n\n  while (el.__stimulusX_cleanups?.length) el.__stimulusX_cleanups.pop()();\n}\n\nexport function startObservingMutations() {\n  observer.observe(document, {\n    subtree: true,\n    childList: true,\n    attributes: true,\n    attributeOldValue: true,\n  });\n\n  currentlyObserving = true;\n}\n\nexport function stopObservingMutations() {\n  flushObserver();\n\n  observer.disconnect();\n\n  currentlyObserving = false;\n}\n\nlet queuedMutations = [];\n\nexport function flushObserver() {\n  let records = observer.takeRecords();\n\n  queuedMutations.push(() => records.length > 0 && onMutate(records));\n\n  let queueLengthWhenTriggered = queuedMutations.length;\n\n  queueMicrotask(() => {\n    // If these two lengths match, then we KNOW that this is the LAST\n    // flush in the current event loop. This way, we can process\n    // all mutations in one batch at the end of everything...\n    if (queuedMutations.length === queueLengthWhenTriggered) {\n      // Now Alpine can process all the mutations...\n      while (queuedMutations.length > 0) queuedMutations.shift()();\n    }\n  });\n}\n\nexport function mutateDom(callback) {\n  if (!currentlyObserving) return callback();\n\n  stopObservingMutations();\n\n  let result = callback();\n\n  startObservingMutations();\n\n  return result;\n}\n\nexport function deferMutations() {\n  isCollecting = true;\n}\n\nexport function flushAndStopDeferringMutations() {\n  isCollecting = false;\n\n  onMutate(deferredMutations);\n\n  deferredMutations = [];\n}\n\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n\n    return;\n  }\n\n  let addedNodes = [];\n  let removedNodes = new Set();\n  let addedAttributes = new Map();\n  let removedAttributes = new Map();\n\n  for (let i = 0; i < mutations.length; i++) {\n    if (mutations[i].target.__stimulusX_ignoreMutationObserver) continue;\n\n    if (mutations[i].type === \"childList\") {\n      mutations[i].removedNodes.forEach((node) => {\n        if (node.nodeType !== 1) return;\n\n        // No need to process removed nodes that haven't been initialized by Alpine...\n        if (!node.__stimulusX_marker) return;\n\n        removedNodes.add(node);\n      });\n\n      mutations[i].addedNodes.forEach((node) => {\n        if (node.nodeType !== 1) return;\n\n        // If the node is a removal as well, that means it's a \"move\" operation and we'll leave it alone...\n        if (removedNodes.has(node)) {\n          removedNodes.delete(node);\n\n          return;\n        }\n\n        // If the node has already been initialized, we'll leave it alone...\n        if (node.__stimulusX_marker) return;\n\n        addedNodes.push(node);\n      });\n    }\n\n    if (mutations[i].type === \"attributes\") {\n      let el = mutations[i].target;\n      let name = mutations[i].attributeName;\n      let oldValue = mutations[i].oldValue;\n\n      let add = () => {\n        if (!addedAttributes.has(el)) addedAttributes.set(el, []);\n\n        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });\n      };\n\n      let remove = () => {\n        if (!removedAttributes.has(el)) removedAttributes.set(el, []);\n\n        removedAttributes.get(el).push(name);\n      };\n\n      // let valueAttributeChanged = () => {\n\n      // };\n\n      // New attribute.\n      if (el.hasAttribute(name) && oldValue === null) {\n        add();\n        // Changed attribute.\n      } else if (el.hasAttribute(name)) {\n        remove();\n        add();\n        // Removed attribute.\n      } else {\n        remove();\n      }\n    }\n  }\n\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach((i) => i(el, attrs));\n  });\n\n  // There are two special scenarios we need to account for when using the mutation\n  // observer to init and destroy elements. First, when a node is \"moved\" on the page,\n  // it's registered as both an \"add\" and a \"remove\", so we want to skip those.\n  // (This is handled above by the .__stimulusX_marker conditionals...)\n  // Second, when a node is \"wrapped\", it gets registered as a \"removal\" and the wrapper\n  // as an \"addition\". We don't want to remove, then re-initialize the node, so we look\n  // and see if it's inside any added nodes (wrappers) and skip it.\n  // (This is handled below by the .contains conditional...)\n\n  for (let node of removedNodes) {\n    if (addedNodes.some((i) => i.contains(node))) continue;\n\n    onElRemoveds.forEach((i) => i(node));\n  }\n\n  for (let node of addedNodes) {\n    if (!node.isConnected) continue;\n\n    onElAddeds.forEach((i) => i(node));\n  }\n\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n}\n","let flushPending = false;\nlet flushing = false;\nlet queue = [];\nlet lastFlushedIndex = -1;\nlet tickStack = [];\nlet isHolding = false;\n\nexport function scheduler(callback) {\n  queueJob(callback);\n}\n\nexport function queueJob(job) {\n  if (!queue.includes(job)) queue.push(job);\n\n  queueFlush();\n}\n\nexport function dequeueJob(job) {\n  let index = queue.indexOf(job);\n\n  if (index !== -1 && index > lastFlushedIndex) queue.splice(index, 1);\n}\n\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n\n    queueMicrotask(flushJobs);\n  }\n}\n\nexport function flushJobs() {\n  flushPending = false;\n  flushing = true;\n\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n    lastFlushedIndex = i;\n  }\n\n  queue.length = 0;\n  lastFlushedIndex = -1;\n\n  flushing = false;\n}\n\nexport function nextTick(callback = () => {}) {\n  queueMicrotask(() => {\n    isHolding ||\n      setTimeout(() => {\n        releaseNextTicks();\n      });\n  });\n\n  return new Promise((res) => {\n    tickStack.push(() => {\n      callback();\n      res();\n    });\n  });\n}\n\nexport function releaseNextTicks() {\n  isHolding = false;\n\n  while (tickStack.length) tickStack.shift()();\n}\n\nexport function holdNextTicks() {\n  isHolding = true;\n}\n","import { effect as vueEffect, stop as release, reactive, raw } from \"@vue/reactivity\";\nimport { scheduler } from \"./scheduler\";\n\nconst effect = (callback) =>\n  vueEffect(callback, {\n    scheduler: scheduler((task) => task),\n  });\n\nexport function elementBoundEffect(el) {\n  let cleanup = () => {};\n\n  let wrappedEffect = (callback) => {\n    let effectReference = effect(callback);\n\n    if (!el.__stimulusX_effects) {\n      el.__stimulusX_effects = new Set();\n    }\n\n    el.__stimulusX_effects.add(effectReference);\n\n    cleanup = () => {\n      if (effectReference === undefined) return;\n\n      el.__stimulusX_effects.delete(effectReference);\n\n      release(effectReference);\n    };\n\n    return effectReference;\n  };\n\n  return [\n    wrappedEffect,\n    () => {\n      cleanup();\n    },\n  ];\n}\n\nexport function watch(getter, callback) {\n  let firstTime = true;\n  let oldValue;\n\n  let effectReference = effect(() => {\n    let value = getter();\n\n    // JSON.stringify touches every single property at any level enabling deep watching\n    JSON.stringify(value);\n\n    if (!firstTime) {\n      // We have to queue this watcher as a microtask so that\n      // the watcher doesn't pick up its own dependencies.\n      queueMicrotask(() => {\n        callback(value, oldValue);\n\n        oldValue = value;\n      });\n    } else {\n      oldValue = value;\n    }\n\n    firstTime = false;\n  });\n\n  return () => release(effectReference);\n}\n\nexport { effect, release, reactive, raw };\n","import { getProperty } from \"dot-prop\";\nimport { reactive, watch } from \"./reactivity\";\nimport { mutateDom } from \"./mutation\";\n\nexport function createReactiveControllerClass(ControllerClass) {\n  return class extends ControllerClass {\n    constructor(context) {\n      super(context);\n\n      // Override the attribute setter so that our mutation observer doesn't pick up on changes\n      // that are also already being handled directly by Stimulus.\n      const setData = this.data.set;\n      this.data.set = (key, value) => {\n        mutateDom(() => setData.call(this.data, key, value));\n      };\n\n      // Create a reactive controller object\n      const self = reactive(this);\n\n      // Initialize watched property callbacks\n      const watchedProps = this.constructor.watch || [];\n      watchedProps.forEach((prop) => watchControllerProperty(self, prop));\n\n      // Return the reactive controller instance\n      return self;\n    }\n  };\n}\n\nexport function getClosestController(el, identifier, application) {\n  const controllerElement = el.closest(`[data-controller~=\"${identifier}\"]`);\n  if (controllerElement) {\n    return application.getControllerForElementAndIdentifier(controllerElement, identifier);\n  }\n}\n\nexport function evaluateControllerProperty(controller, property) {\n  let value = getProperty(controller, property);\n  if (typeof value === \"function\") {\n    value = value.apply(controller);\n  }\n  return value;\n}\n\nexport function watchControllerProperty(controller, propertyRef) {\n  const getter = () => evaluateControllerProperty(controller, propertyRef);\n  const cleanup = watch(getter, (value, oldValue) => {\n    callCallbacks(controller, propertyRef, value, oldValue, false);\n  });\n\n  // Run once on creation\n  callCallbacks(controller, propertyRef, getter(), undefined, true);\n\n  const rootElement = controller.element;\n  if (!rootElement.__stimulusX_cleanups) rootElement.__stimulusX_cleanups = [];\n  rootElement.__stimulusX_cleanups.push(cleanup);\n}\n\nfunction callCallbacks(controller, propertyRef, value, oldValue, initial) {\n  // Generic callback, called when _any_ watched property changes\n  if (typeof controller.watchedPropertyChanged === \"function\") {\n    controller.watchedPropertyChanged(propertyRef, value, oldValue, { initial });\n  }\n\n  // Property-specific change callback\n  const propertyWatcherCallback =\n    controller[`${getCamelizedPropertyRef(propertyRef)}PropertyChanged`];\n  if (typeof propertyWatcherCallback === \"function\") {\n    propertyWatcherCallback.call(controller, value, oldValue, { initial });\n  }\n}\n\nfunction getCamelizedPropertyRef(propertyRef) {\n  return camelCase(propertyRef.replace(\".\", \" \"));\n}\n\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\n","export function camelCase(subject) {\n  return subject\n    .replace(/:/g, \"_\")\n    .split(\"_\")\n    .map((word, index) => (index === 0 ? word : word[0].toUpperCase() + word.slice(1)))\n    .join(\"\");\n}\n\nexport function walk(el, callback) {\n  let skip = false;\n  callback(el, () => (skip = true));\n  if (skip) return;\n\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"downcase\", (value) => value.toString().toLowerCase());\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"not\", (value) => !value);\n","import { modifier } from \"../modifiers\";\n\nmodifier(\"upcase\", (value) => value.toString().toUpperCase());\n","import { directive } from \"../directives\";\nimport { mutateDom } from \"../mutation\";\nimport { bind } from \"../attributes\";\n\ndirective(\"attr\", (el, { property, subject, modifiers }, { effect, evaluate, modify }) => {\n  effect(() => {\n    mutateDom(() => {\n      const value = modify(evaluate(property), modifiers);\n      bind(el, subject, value);\n    });\n  });\n});\n","import { setClasses } from \"./classes\";\n\n// As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\nconst booleanAttributes = new Set([\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"inert\",\n  \"ismap\",\n  \"itemscope\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\",\n]);\n\nconst preserveIfFalsey = [\"aria-pressed\", \"aria-checked\", \"aria-expanded\", \"aria-selected\"];\n\nexport function bind(element, name, value) {\n  switch (name) {\n    case \"class\":\n      bindClasses(element, value);\n      break;\n\n    case \"checked\":\n    case \"selected\":\n      bindAttributeAndProperty(element, name, value);\n      break;\n\n    default:\n      bindAttribute(element, name, value);\n      break;\n  }\n}\n\nfunction bindClasses(element, value) {\n  if (element.__stimulusX_undoClasses) element.__stimulusX_undoClasses();\n  element.__stimulusX_undoClasses = setClasses(element, value);\n}\n\nfunction bindAttribute(el, name, value) {\n  if ([null, undefined, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name)) value = name;\n    setIfChanged(el, name, value);\n  }\n}\n\nfunction bindAttributeAndProperty(el, name, value) {\n  bindAttribute(el, name, value);\n  setPropertyIfChanged(el, name, value);\n}\n\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\n\nfunction setPropertyIfChanged(el, propName, value) {\n  if (el[propName] !== value) {\n    el[propName] = value;\n  }\n}\n\nfunction isBooleanAttr(attrName) {\n  return booleanAttributes.has(attrName);\n}\n\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return !preserveIfFalsey.includes(name);\n}\n","export function setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  }\n  return setClassesFromString(el, value);\n}\n\nfunction setClassesFromString(el, classString) {\n  classString = classString || \"\";\n  let missingClasses = (classString) =>\n    classString\n      .split(\" \")\n      .filter((i) => !el.classList.contains(i))\n      .filter(Boolean);\n\n  let classes = missingClasses(classString);\n  el.classList.add(...classes);\n\n  return () => el.classList.remove(...classes);\n}\n\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n\n  let forAdd = Object.entries(classObject)\n    .flatMap(([classString, bool]) => (bool ? split(classString) : false))\n    .filter(Boolean);\n  let forRemove = Object.entries(classObject)\n    .flatMap(([classString, bool]) => (!bool ? split(classString) : false))\n    .filter(Boolean);\n\n  let added = [];\n  let removed = [];\n\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n","import { directive } from \"../directives\";\nimport { mutateDom } from \"../mutation\";\n\ndirective(\"text\", (el, { property, modifiers }, { effect, evaluate, modify }) => {\n  effect(() =>\n    mutateDom(() => {\n      const value = modify(evaluate(property), modifiers);\n      el.textContent = value;\n    })\n  );\n});\n"],"names":[],"version":3,"file":"stimulus-x.cjs.js.map"}